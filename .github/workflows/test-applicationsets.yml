name: Test ApplicationSets

on:
  pull_request:
    branches: [ main ]
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  # renovate: datasource=github-releases depName=argoproj/argo-cd
  ARGOCD_VERSION: v2.12.3
  # renovate: datasource=github-releases depName=kubernetes/kubernetes
  KUBECTL_VERSION: v1.28.0

jobs:
  test-monitoring:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Create kind config file
      run: |
        cat << EOF > kind-config.yaml
        kind: Cluster
        apiVersion: kind.x-k8s.io/v1alpha4
        nodes:
        - role: control-plane
          kubeadmConfigPatches:
          - |
            kind: InitConfiguration
            nodeRegistration:
              kubeletExtraArgs:
                node-labels: "ingress-ready=true"
          extraPortMappings:
          - containerPort: 80
            hostPort: 80
            protocol: TCP
          - containerPort: 443
            hostPort: 443
            protocol: TCP
        EOF

    - name: Create kind cluster
      uses: helm/kind-action@v1
      with:
        version: v0.20.0
        kubectl_version: ${{ env.KUBECTL_VERSION }}
        cluster_name: test-cluster
        wait: 300s
        config: kind-config.yaml

    - name: Verify cluster is ready
      run: |
        echo "Cluster info:"
        kubectl cluster-info
        echo "Nodes:"
        kubectl get nodes -o wide
        echo "Pods in kube-system:"
        kubectl get pods -n kube-system

    - name: Install ArgoCD
      run: |
        echo "Creating argocd namespace..."
        kubectl create namespace argocd
        
        echo "Installing ArgoCD ${{ env.ARGOCD_VERSION }}..."
        kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/${{ env.ARGOCD_VERSION }}/manifests/install.yaml
        
        echo "Waiting for ArgoCD components to be ready..."
        kubectl wait --for=condition=available --timeout=600s deployment/argocd-server -n argocd
        kubectl wait --for=condition=available --timeout=600s deployment/argocd-repo-server -n argocd
        kubectl wait --for=condition=available --timeout=600s deployment/argocd-redis -n argocd
        kubectl wait --for=condition=available --timeout=600s deployment/argocd-dex-server -n argocd
        
        echo "Waiting for ArgoCD application controller (StatefulSet)..."
        kubectl wait --for=jsonpath='{.status.readyReplicas}'=1 --timeout=600s statefulset/argocd-application-controller -n argocd

    - name: Setup ArgoCD CLI
      run: |
        echo "Downloading ArgoCD CLI..."
        curl -sSL -o argocd-linux-amd64 https://github.com/argoproj/argo-cd/releases/download/${{ env.ARGOCD_VERSION }}/argocd-linux-amd64
        sudo install -m 555 argocd-linux-amd64 /usr/local/bin/argocd
        rm argocd-linux-amd64
        
        echo "ArgoCD CLI version:"
        argocd version --client

    - name: Port forward ArgoCD server
      run: |
        echo "Starting port-forward to ArgoCD server..."
        kubectl port-forward svc/argocd-server -n argocd 8080:443 &
        sleep 10
        
        # Wait for port to be available
        timeout 60 bash -c 'until nc -z localhost 8080; do sleep 1; done'
        echo "ArgoCD server is accessible on localhost:8080"

    - name: Get ArgoCD admin password and login
      run: |
        echo "Getting ArgoCD admin password..."
        ARGOCD_PASSWORD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath="{.data.password}" | base64 -d)
        echo "::add-mask::$ARGOCD_PASSWORD"
        
        echo "Logging in to ArgoCD..."
        argocd login localhost:8080 --username admin --password "$ARGOCD_PASSWORD" --insecure
        
        echo "ArgoCD account info:"
        argocd account get --server localhost:8080
    

    - name: Create local cluster secret with monitoring label
      run: |
        echo "Creating secret for local cluster with monitoring label..."
        
        # Create a secret for the local cluster so we can add labels to it
        kubectl create secret generic test-cluster \
          --from-literal=name=test-cluster \
          --from-literal=server=https://kubernetes.default.svc \
          --from-literal=config='{"tlsClientConfig":{"insecure":true}}' \
          -n argocd
        
        # Add required labels to the secret
        kubectl label secret test-cluster \
          argocd.argoproj.io/secret-type=cluster \
          monitoring=enabled \
          -n argocd
        
        echo "Verifying cluster secret:"
        kubectl get secret test-cluster -n argocd -o yaml
        
        echo "Checking clusters available to ArgoCD:"
        argocd cluster list --server localhost:8080

    - name: Check ArgoCD is ready
      run: |
        echo "ArgoCD clusters available:"
        argocd cluster list --server localhost:8080
        

    - name: Apply monitoring ApplicationSet and test
      run: |
        echo "Applying monitoring ApplicationSet..."
        kubectl apply -f monitoring/kube-prometheus-stack-with-loki/basic/applicationset.yaml
        
        kubectl get applicationsets -n argocd
        
        echo "Waiting for ApplicationSet to generate applications..."
        sleep 45
        
        echo "Applications generated:"
        kubectl get applications -n argocd
        kubectl describe applicationset kube-prometheus-stack -n argocd

    - name: Wait for monitoring application to sync
      run: |
        echo "Waiting for monitoring application to be created and synced..."
        timeout 900 bash -c '
          while true; do
            if kubectl get application test-cluster-monitoring -n argocd &>/dev/null; then
              STATUS=$(kubectl get application test-cluster-monitoring -n argocd -o jsonpath="{.status.sync.status}")
              HEALTH=$(kubectl get application test-cluster-monitoring -n argocd -o jsonpath="{.status.health.status}")
              echo "Application sync status: $STATUS, health status: $HEALTH"
              
              # Show more details about what's happening
              if [[ "$HEALTH" == "Progressing" ]]; then
                echo "Checking pod status in monitoring namespace:"
                kubectl get pods -n monitoring --no-headers | grep -v Running | head -5 || true
              fi
              
              if [[ "$STATUS" == "Synced" && "$HEALTH" == "Healthy" ]]; then
                echo "Application is synced and healthy!"
                break
              fi
            else
              echo "Application not found yet, waiting..."
            fi
            sleep 15  # Reduced frequency since monitoring stacks take time
          done
        '

    - name: Verify monitoring components are deployed
      run: |
        echo "Checking if monitoring namespace was created..."
        kubectl get namespace monitoring
        
        echo "Verifying Prometheus components..."
        kubectl get pods -n monitoring | grep prometheus
        
        echo "Verifying Grafana is deployed..."
        kubectl get pods -n monitoring | grep grafana
        
        echo "Verifying Loki is deployed..."
        kubectl get pods -n monitoring | grep loki
        
        echo "Verifying Promtail is deployed..."
        kubectl get pods -n monitoring | grep promtail
        
        echo "All monitoring pods:"
        kubectl get pods -n monitoring

    - name: Wait for all monitoring pods to be ready
      run: |
        echo "Waiting for all monitoring pods to be ready..."
        kubectl wait --for=condition=ready --timeout=600s pods --all -n monitoring
        
        echo "Final pod status:"
        kubectl get pods -n monitoring -o wide

    - name: Verify services are accessible
      run: |
        echo "Checking monitoring services..."
        kubectl get services -n monitoring
        
        echo "Testing Prometheus connectivity..."
        kubectl port-forward -n monitoring svc/prometheus-kube-prometheus-prometheus 9090:9090 &
        sleep 5
        timeout 30 bash -c 'until nc -z localhost 9090; do sleep 1; done'
        curl -f http://localhost:9090/-/healthy || echo "Prometheus health check failed"
        pkill -f "port-forward.*9090" || true
        
        echo "Testing Grafana connectivity..."
        kubectl port-forward -n monitoring svc/prometheus-grafana 3000:80 &
        sleep 5
        timeout 30 bash -c 'until nc -z localhost 3000; do sleep 1; done'
        curl -f http://localhost:3000/api/health || echo "Grafana health check failed"
        pkill -f "port-forward.*3000" || true

    - name: Check application status in ArgoCD
      run: |
        echo "Final ArgoCD application status:"
        argocd app get test-cluster-monitoring --server localhost:8080
        
        echo "Application sync history:"
        argocd app history test-cluster-monitoring --server localhost:8080

    - name: Debug on failure
      if: failure()
      run: |
        echo "=== DEBUGGING INFORMATION ==="
        
        echo "ArgoCD Applications:"
        kubectl get applications -n argocd -o wide
        
        echo "ArgoCD ApplicationSets:"
        kubectl get applicationsets -n argocd -o wide
        
        echo "ArgoCD Server logs:"
        kubectl logs -n argocd deployment/argocd-server --tail=50 || true
        
        echo "ArgoCD Application Controller logs:"
        kubectl logs -n argocd deployment/argocd-application-controller --tail=50 || true
        
        echo "All pods in monitoring namespace:"
        kubectl get pods -n monitoring -o wide || true
        
        echo "Events in monitoring namespace:"
        kubectl get events -n monitoring --sort-by=.metadata.creationTimestamp || true
        
        echo "Persistent volumes:"
        kubectl get pv,pvc -A || true
        
        if kubectl get application test-cluster-monitoring -n argocd &>/dev/null; then
          echo "Application details:"
          kubectl describe application test-cluster-monitoring -n argocd || true
        fi